#!/bin/bash
# Enhanced ed wrapper for Claude Code
# Usage: eed [--debug] <file> <ed_commands...>
#
# Options:
#   --debug    Enable debug mode (preserve temp files, show ed output)
#
# Examples:
#   eed file.txt "5d"                           # Delete line 5
#   eed file.txt "3c" "new content" "."         # Replace line 3
#   eed file.txt "5a" "new line" "."            # Insert after line 5
#   eed file.txt "1,3d"                         # Delete lines 1-3
#   eed file.txt "s/old/new/g"                  # Replace all 'old' with 'new' on current line
#   eed file.txt "1,\$s/old/new/g"              # Replace all 'old' with 'new' in entire file

set -e

# Debug mode flag
DEBUG_MODE=false

show_usage() {
    echo "Usage: eed [--debug] <file> <ed_script>"
    echo ""
    echo "Single-parameter mode with heredoc support for complex operations."
    echo ""
    echo "Options:"
    echo "  --debug    Enable debug mode (preserve temp files, verbose errors)"
    echo ""
    echo "Common ed commands:"
    echo "  Nd             - Delete line N"
    echo "  N,Md           - Delete lines N through M"
    echo "  Nc <text> .    - Replace line N with <text>"
    echo "  Na <text> .    - Insert <text> after line N"
    echo "  Ni <text> .    - Insert <text> before line N"
    echo "  ,p             - Print all lines (view file)"
    echo "  N,Mp           - Print lines N through M"
    echo "  /pattern/p     - Print lines matching pattern"
    echo "  s/old/new/g    - Replace all 'old' with 'new' on current line"
    echo "  1,\$s/old/new/g - Replace all 'old' with 'new' in entire file"
    echo ""
    echo "Examples:"
    echo '  eed file.txt "5d\nw\nq"                    # Delete line 5'
    echo '  eed file.txt ",p\nq"                       # View entire file'
    echo '  eed file.txt "$(cat <<'\''EOF'\''            # Complex operations'
    echo '  3c'
    echo '  new content'
    echo '  .'
    echo '  w'
    echo '  q'
    echo '  EOF'
    echo '  )"'
}

# Parse debug flag
if [ "$1" = "--debug" ]; then
    DEBUG_MODE=true
    shift
fi

# Enforce single parameter mode - reject multi-parameter syntax
if [ $# -ne 2 ]; then
    echo "Error: eed now uses single-parameter mode only" >&2
    echo "Usage: eed <file> <ed_script>" >&2
    echo "" >&2
    echo "Use heredoc syntax for complex operations:" >&2
    echo 'Example with heredoc:' >&2
    echo 'eed file.txt "$(cat <<EOF_EXAMPLE' >&2
    echo '3c' >&2
    echo 'new content' >&2  
    echo '.' >&2
    echo 'w' >&2
    echo 'q' >&2
    echo 'EOF_EXAMPLE' >&2
    echo ')"' >&2
    exit 1
fi
validate_ed_script() {
    local script="$1"
    
    # Check for empty script - treat as no-op, not error
    if [ -z "$script" ] || [ "$script" = "" ]; then
        echo "Warning: Empty ed script provided - no operations to perform" >&2
        return 0  # Success but no operations
    fi
    
    # Check if script ends with 'q' or 'Q' command
    if ! echo "$script" | grep -q '[qQ]$'; then
        echo "Warning: Ed script does not end with 'q' or 'Q' command" >&2
        echo "This may cause ed to wait for input or hang" >&2
        echo "Consider adding 'q' (save and quit) or 'Q' (quit without save) at the end" >&2
        # Don't fail - just warn, as user might intentionally want this
    fi
    
    return 0
}

FILE="$1"
ED_SCRIPT="$2"

# Validate the ed script
validation_result=$(validate_ed_script "$ED_SCRIPT")
validation_code=$?
echo "$validation_result" >&2

if [ $validation_code -ne 0 ]; then
    exit 1
fi

# Handle empty script case - no operations needed
if [ -z "$ED_SCRIPT" ] || [ "$ED_SCRIPT" = "" ]; then
    echo "✓ No operations performed (empty script)"
    exit 0
fi

# Check if file exists, create if needed
if [ ! -f "$FILE" ]; then
    echo "Creating new file: $FILE"
    echo > "$FILE"  # Create file with one empty line instead of zero bytes
fi

# Create backup
cp "$FILE" "$FILE.eed.bak"

# Create secure temporary command file
TEMP_CMD_FILE=$(mktemp)
# Cleanup function to ensure temp file is removed
cleanup() {
    if [ "$DEBUG_MODE" = false ]; then
        rm -f "$TEMP_CMD_FILE"
    else
        echo "Debug mode: temporary file preserved at $TEMP_CMD_FILE" >&2
    fi
}
trap cleanup EXIT

# Write the complete ed script to temp file
printf '%s\n' "$ED_SCRIPT" >> "$TEMP_CMD_FILE"

# Note: No automatic w/q injection - user controls save/exit

# Execute ed with error handling
if [ "$DEBUG_MODE" = true ]; then
    # Debug mode: show ed output
    echo "Debug mode: executing ed with commands from $TEMP_CMD_FILE" >&2
    echo "Debug mode: ed command file contents:" >&2
    cat -n "$TEMP_CMD_FILE" >&2
    echo "Debug mode: ed output:" >&2
    ed -s "$FILE" < "$TEMP_CMD_FILE"
    ED_EXIT_CODE=$?
else
    # Normal mode: show ed output for viewing functionality
    ed -s "$FILE" < "$TEMP_CMD_FILE"
    ED_EXIT_CODE=$?

fi
if [ $ED_EXIT_CODE -eq 0 ]; then
    echo "✓ Successfully edited $FILE"
    # Remove backup on success (temp file cleaned by trap)
    rm -f "$FILE.eed.bak"
else
    echo "✗ Error: ed command failed, restoring backup" >&2
    mv "$FILE.eed.bak" "$FILE"
    echo "Commands attempted:" >&2
    head -n -2 "$TEMP_CMD_FILE" >&2  # Show commands without w/q
    exit 1
fi
