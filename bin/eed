#!/bin/bash
# Enhanced ed wrapper for Claude Code
# Usage: eed [--debug] <file> <ed_commands...>
#
# Options:
#   --debug    Enable debug mode (preserve temp files, show ed output)
#
# Examples:
#   eed file.txt "5d"                           # Delete line 5
#   eed file.txt "3c" "new content" "."         # Replace line 3
#   eed file.txt "5a" "new line" "."            # Insert after line 5
#   eed file.txt "1,3d"                         # Delete lines 1-3
#   eed file.txt "s/old/new/g"                  # Replace all 'old' with 'new' on current line
#   eed file.txt "1,\$s/old/new/g"              # Replace all 'old' with 'new' in entire file

# Removed set -e to allow proper error handling

# Load library functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/eed_common.sh"
source "$SCRIPT_DIR/lib/eed_validator.sh"

# Debug mode flag
DEBUG_MODE=false

# Parse debug flag
if [ "$1" = "--debug" ]; then
    DEBUG_MODE=true
    shift
fi

# Enforce single parameter mode - reject multi-parameter syntax
if [ $# -ne 2 ]; then
    echo "Error: eed now uses single-parameter mode only" >&2
    echo "Usage: eed <file> <ed_script>" >&2
    echo "" >&2
    echo "Use heredoc syntax for complex operations:" >&2
    echo 'Example with heredoc:' >&2
    echo 'eed file.txt "$(cat <<EOF_EXAMPLE' >&2
    echo '3c' >&2
    echo 'new content' >&2
    echo '.' >&2
    echo 'w' >&2
    echo 'q' >&2
    echo 'EOF_EXAMPLE' >&2
    echo ')"' >&2
    exit 1
fi

FILE="$1"
ED_SCRIPT="$2"

# Validate the ed script
validation_result=$(validate_ed_script "$ED_SCRIPT")
validation_code=$?
echo "$validation_result" >&2

if [ $validation_code -ne 0 ]; then
    exit 1
fi

# Handle empty script case - no operations needed
if [ -z "$ED_SCRIPT" ] || [ "$ED_SCRIPT" = "" ]; then
    echo "✓ No operations performed (empty script)"
    exit 0
fi

# Check if file exists, create if needed
if [ ! -f "$FILE" ]; then
    echo "Creating new file: $FILE"
    echo > "$FILE"  # Create file with one empty line instead of zero bytes
fi

# Classify and validate script
SCRIPT_TYPE=$(classify_ed_script "$ED_SCRIPT")

# Handle invalid commands before executing ed
if [ "$SCRIPT_TYPE" = "invalid_command" ]; then
    echo "✗ Error: Invalid ed command detected" >&2
    echo "Script contains unrecognized commands:" >&2
    echo "$ED_SCRIPT" >&2
    exit 1
fi

# Create backup only for modifying scripts
if [ "$SCRIPT_TYPE" = "has_modifying" ]; then
    cp "$FILE" "$FILE.eed.bak"
    BACKUP_CREATED=true
else
    BACKUP_CREATED=false
fi

# Create secure temporary command file
TEMP_CMD_FILE=$(mktemp)
# Cleanup function to ensure temp file is removed
cleanup() {
    if [ "$DEBUG_MODE" = false ]; then
        rm -f "$TEMP_CMD_FILE"
    else
        echo "Debug mode: temporary file preserved at $TEMP_CMD_FILE" >&2
    fi
}
trap cleanup EXIT

# Write the complete ed script to temp file
printf '%s\n' "$ED_SCRIPT" >> "$TEMP_CMD_FILE"

# Note: No automatic w/q injection - user controls save/exit

# Execute ed with error handling
if [ "$DEBUG_MODE" = true ]; then
    # Debug mode: show ed output
    echo "Debug mode: executing ed with commands from $TEMP_CMD_FILE" >&2
    echo "Debug mode: ed command file contents:" >&2
    cat -n "$TEMP_CMD_FILE" >&2
    echo "Debug mode: ed output:" >&2
    ed -s "$FILE" < "$TEMP_CMD_FILE"
    ED_EXIT_CODE=$?
else
    # Normal mode: show ed output for viewing functionality
    ed -s "$FILE" < "$TEMP_CMD_FILE"
    ED_EXIT_CODE=$?

fi

# Handle ed result based on exit code and script type
case $ED_EXIT_CODE in
    0)
        # Normal completion
        echo "✓ Successfully processed $FILE"
        if [ "$BACKUP_CREATED" = true ]; then
            rm -f "$FILE.eed.bak"
        fi
        ;;
    1)
        # Command failed - decision based on script type
        if [ "$SCRIPT_TYPE" = "view_only" ]; then
            # View operations (including invalid commands) fail gracefully
            echo "✓ View operation completed (no matches found or invalid command)"
            # No backup to clean up for view_only scripts
            exit 0
        else
            # Modifying operations that fail should restore backup
            echo "✗ Edit command failed, restoring backup" >&2
            if [ "$BACKUP_CREATED" = true ]; then
                mv "$FILE.eed.bak" "$FILE"
            fi
            echo "Commands attempted:" >&2
            cat "$TEMP_CMD_FILE" >&2
            exit 1
        fi
        ;;
    2)
        # File I/O problems - always fail
        echo "✗ File I/O error, restoring backup" >&2
        if [ "$BACKUP_CREATED" = true ]; then
            mv "$FILE.eed.bak" "$FILE"
        fi
        exit 2
        ;;
    3)
        # Internal ed error - always fail
        echo "✗ Internal ed error, restoring backup" >&2
        if [ "$BACKUP_CREATED" = true ]; then
            mv "$FILE.eed.bak" "$FILE"
        fi
        exit 3
        ;;
esac
