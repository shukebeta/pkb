#!/bin/bash

set -uo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test counters
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Test directory
TEST_DIR="/tmp/gs_test_$$"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Cleanup function
cleanup() {
    rm -rf "$TEST_DIR"
}

# Trap cleanup on exit
trap cleanup EXIT

# Print colored output
print_status() {
    local status="$1"
    local message="$2"
    case "$status" in
        "PASS") echo -e "${GREEN}✓ PASS${NC}: $message" ;;
        "FAIL") echo -e "${RED}✗ FAIL${NC}: $message" ;;
        "INFO") echo -e "${BLUE}ℹ INFO${NC}: $message" ;;
        "WARN") echo -e "${YELLOW}⚠ WARN${NC}: $message" ;;
    esac
}

# Test assertion function
assert_equal() {
    local expected="$1"
    local actual="$2"
    local test_name="$3"
    
    ((TOTAL_TESTS++))
    
    if [[ "$expected" == "$actual" ]]; then
        print_status "PASS" "$test_name"
        ((PASSED_TESTS++))
        return 0
    else
        print_status "FAIL" "$test_name"
        echo "  Expected: '$expected'"
        echo "  Actual  : '$actual'"
        ((FAILED_TESTS++))
        return 1
    fi
}

# Test file content assertion
assert_file_content() {
    local expected="$1"
    local file="$2"
    local test_name="$3"
    
    ((TOTAL_TESTS++))
    
    if [[ -f "$file" ]]; then
        local actual
        actual=$(cat "$file")
        if [[ "$expected" == "$actual" ]]; then
            print_status "PASS" "$test_name"
            ((PASSED_TESTS++))
            return 0
        else
            print_status "FAIL" "$test_name"
            echo "  Expected content: '$expected'"
            echo "  Actual content  : '$actual'"
            ((FAILED_TESTS++))
            return 1
        fi
    else
        print_status "FAIL" "$test_name (file not found)"
        ((FAILED_TESTS++))
        return 1
    fi
}

# Setup test environment
setup_test_env() {
    mkdir -p "$TEST_DIR"
    cd "$TEST_DIR"
    
    # Create test files with known content
    echo "hello world" > "test1.txt"
    echo "function test() { return 42; }" > "test2.js"
    echo "var oldVar = 'value';" > "test3.js"
    echo "2023-12-25 Christmas" > "dates.txt"
    
    print_status "INFO" "Test environment created in $TEST_DIR"
}

# Test basic search functionality
test_search_basic() {
    print_status "INFO" "Testing basic search functionality..."
    
    # Test simple search
    local output
    output=$("$SCRIPT_DIR/g" "hello" . 2>&1) 
    if echo "$output" | grep -q "test1.txt"; then
        print_status "PASS" "Basic search finds correct file"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Basic search failed"
        echo "Output: $output"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
    
    # Test no matches
    local no_match_output
    no_match_output=$("$SCRIPT_DIR/g" "nonexistent" . 2>&1) 
    if echo "$no_match_output" | grep -q "No matches found"; then
        print_status "PASS" "No matches correctly reported"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "No matches not handled correctly"
        echo "Output: $no_match_output"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
}

# Test basic replacement functionality
test_replace_basic() {
    print_status "INFO" "Testing basic replacement functionality..."
    
    # Test simple replacement
    local original_content
    original_content=$(cat test1.txt)
    
    # Run replacement (no confirmation needed)
    "$SCRIPT_DIR/s" "hello" "hi" . >/dev/null 2>&1
    
    local new_content
    new_content=$(cat test1.txt)
    
    assert_equal "hi world" "$new_content" "Simple text replacement works"
    
    # Restore for next test
    echo "$original_content" > test1.txt
}

# Test regex replacement
test_replace_regex() {
    print_status "INFO" "Testing regex replacement functionality..."
    
    # Test word boundary replacement
    local original_content
    original_content=$(cat test3.js)
    
    # Run regex replacement
    "$SCRIPT_DIR/s" '\bvar\b' 'let' . >/dev/null 2>&1
    
    local new_content
    new_content=$(cat test3.js)
    
    assert_equal "let oldVar = 'value';" "$new_content" "Regex word boundary replacement works"
    
    # Restore
    echo "$original_content" > test3.js
}

# Test capture groups
test_replace_capture_groups() {
    print_status "INFO" "Testing capture group replacement..."
    
    # Test capture groups with date format
    local original_dates
    original_dates=$(cat dates.txt)
    
    # Replace YYYY-MM-DD with DD/MM/YYYY
    "$SCRIPT_DIR/s" '([0-9]{4})-([0-9]{2})-([0-9]{2})' '$3/$2/$1' . >/dev/null 2>&1
    
    local new_dates
    new_dates=$(cat dates.txt)
    
    assert_equal "25/12/2023 Christmas" "$new_dates" "Capture group replacement works"
    
    # Restore
    echo "$original_dates" > dates.txt
}

# Test dry-run functionality
test_dry_run() {
    print_status "INFO" "Testing dry-run functionality..."
    
    local original_content
    original_content=$(cat test1.txt)
    
    # Run dry-run
    local dry_run_output
    dry_run_output=$("$SCRIPT_DIR/s" "world" "universe" . --dry-run 2>&1)
    
    # Check that dry-run was indicated
    if echo "$dry_run_output" | grep -q "DRY RUN"; then
        print_status "PASS" "Dry-run mode activated"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Dry-run mode not indicated"
        echo "Output: $dry_run_output"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
    
    # Check file was not modified
    local after_dry_run
    after_dry_run=$(cat test1.txt)
    
    assert_equal "$original_content" "$after_dry_run" "Dry-run preserves original file"
}

# Test error handling
test_error_handling() {
    print_status "INFO" "Testing error handling..."
    
    # Test empty pattern
    local empty_pattern_output
    empty_pattern_output=$("$SCRIPT_DIR/g" "" . 2>&1) && local empty_exit_code=0 || local empty_exit_code=$?
    
    if [[ $empty_exit_code -ne 0 ]]; then
        print_status "PASS" "Empty pattern rejected with non-zero exit code"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Empty pattern should be rejected"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
    
    # Test non-existent directory
    local bad_dir_output
    bad_dir_output=$("$SCRIPT_DIR/g" "test" "/nonexistent" 2>&1) && local bad_dir_exit=0 || local bad_dir_exit=$?
    
    if [[ $bad_dir_exit -ne 0 ]]; then
        print_status "PASS" "Non-existent directory rejected"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Non-existent directory should be rejected"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
}

# Test successful exit codes
test_exit_codes() {
    test_single_file_operations    test_single_file_error_handling
    print_status "INFO" "Testing exit codes..."
    
    # Test successful replacement returns 0
    echo "test content" > exit_test.txt
    "$SCRIPT_DIR/s" "test" "example" . >/dev/null 2>&1
    local success_exit=$?
    
    assert_equal "0" "$success_exit" "Successful replacement returns exit code 0"
    
    # Test successful search returns 0
    "$SCRIPT_DIR/g" "example" . >/dev/null 2>&1
    local search_exit=$?
    
    assert_equal "0" "$search_exit" "Successful search returns exit code 0"
}

# Main test runner
main() {
    echo "===========================================" 
    echo "  Testing G/S Search and Replace Tools"
    echo "==========================================="
    echo ""
    
    # Check if tools exist
    if [[ ! -f "$SCRIPT_DIR/g" ]] || [[ ! -f "$SCRIPT_DIR/s" ]]; then
        print_status "FAIL" "Tools g and s not found in $SCRIPT_DIR"
        exit 1
    fi
    
    print_status "INFO" "Tools found: $SCRIPT_DIR/g, $SCRIPT_DIR/s"
    
    # Setup test environment
    setup_test_env
    
    # Run all tests
    test_search_basic
    test_replace_basic
    test_replace_regex
    test_replace_capture_groups
    test_dry_run
    test_error_handling
    test_exit_codes
    test_single_file_operations    test_single_file_error_handling
    
    # Print summary
    echo ""
    echo "==========================================="
    echo "  Test Summary"
    echo "==========================================="
    echo "Total tests: $TOTAL_TESTS"
    echo -e "Passed: ${GREEN}$PASSED_TESTS${NC}"
    echo -e "Failed: ${RED}$FAILED_TESTS${NC}"
    
    if [[ $FAILED_TESTS -eq 0 ]]; then
        echo -e "\n${GREEN}All tests passed!${NC}"
        exit 0
    else
        echo -e "\n${RED}Some tests failed!${NC}"
        exit 1
    fi
}

# Run main function
# Test single file functionality
test_single_file_operations() {
    print_status "INFO" "Testing single file operations..."
    
    # Create a test file
    echo "single file content for testing" > single_test.txt
    echo "another line with pattern" >> single_test.txt
    
    # Test single file search
    local search_output
    search_output=$("$SCRIPT_DIR/g" "pattern" single_test.txt 2>/dev/null)
    if echo "$search_output" | grep -q "pattern"; then
        print_status "PASS" "Single file search works"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Single file search failed"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
    
    # Test single file replacement
    "$SCRIPT_DIR/s" "pattern" "replacement" single_test.txt >/dev/null 2>&1
    local file_content
    file_content=$(cat single_test.txt)
    
    if echo "$file_content" | grep -q "replacement"; then
        print_status "PASS" "Single file replacement works"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Single file replacement failed"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
    
    # Test single file dry-run
    echo "dry run test content" > dry_run_single.txt
    local dry_run_output
    dry_run_output=$("$SCRIPT_DIR/s" "test" "modified" dry_run_single.txt --dry-run 2>/dev/null)
    
    if echo "$dry_run_output" | grep -q "DRY RUN"; then
        print_status "PASS" "Single file dry-run works"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Single file dry-run failed"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
    
    # Verify dry-run didn't change file
    local original_content
    original_content=$(cat dry_run_single.txt)
    if [[ "$original_content" == "dry run test content" ]]; then
        print_status "PASS" "Dry-run preserves file content"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Dry-run modified file content"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
}

# Test single file error handling
test_single_file_error_handling() {
    print_status "INFO" "Testing single file error handling..."
    
    # Test non-existent file
    local nonexistent_output
    nonexistent_output=$("$SCRIPT_DIR/s" "test" "replacement" "/nonexistent/file.txt" 2>&1) && local nonexistent_exit=0 || local nonexistent_exit=$?
    
    if [[ $nonexistent_exit -ne 0 ]]; then
        print_status "PASS" "Non-existent file rejected"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Non-existent file should be rejected"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
}
main "$@"
